<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multi-Face Detection with MediaPipe</title>
  <style>
    body {
      margin: 0;
      background-color: #000;
      overflow: hidden;
    }
    .video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }

    .overlay-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        pointer-events: none;
    }

    .overlay-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      object-fit: cover;
    }
    canvas {
      z-index: 10;
    }
    #face_count_display {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.5em;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 8px 15px;
      border-radius: 8px;
      z-index: 100;
    }
    #character_image_display {
    position: fixed;
    bottom: -2px;
    right: 20px;
    width: 612px;
    height: auto;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    z-index: 150;
    }
  </style>
</head>
<body>

<div class="video-container">
    <div class="overlay-image">
        <img src="assets/images/Mickey and Friends TV Frame.webp" alt="Overlay Image" >
    </div>
  <video id="input_video" autoplay playsinline muted width="960" height="720"></video>
  <canvas id="output_canvas" width="960" height="720"></canvas>
</div>
<div id="face_count_display">Faces detected: 0</div>
<img id="character_image_display" src="" alt="Character">

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
  const videoElement = document.getElementById('input_video');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const faceCountElement = document.getElementById('face_count_display');
  const characterImageElement = document.getElementById('character_image_display');

  const hatImage = new Image();
  hatImage.src = 'assets/images/mickey headband-01.webp';

  const characterImagePaths = [
    'assets/images/characters/1.webp',
    'assets/images/characters/2.webp',
    'assets/images/characters/3.webp'
  ];
  let currentCharacterIndex = 0;

  function setAndFadeInCharacter() {
    characterImageElement.src = characterImagePaths[currentCharacterIndex];
    
    const fadeInImage = () => {
        characterImageElement.style.opacity = 1;
        characterImageElement.onload = null;
    };

    if (characterImageElement.complete) {
        fadeInImage();
    } else {
        characterImageElement.onload = fadeInImage;
    }
  }

  function cycleCharacter() {
    characterImageElement.style.opacity = 0;

    setTimeout(() => {
      currentCharacterIndex = (currentCharacterIndex + 1) % characterImagePaths.length;
      setAndFadeInCharacter();
    }, 500);
  }

  setAndFadeInCharacter();

  setInterval(cycleCharacter, 60000);

  const faceMesh = new FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });

  faceMesh.setOptions({
    maxNumFaces: 5,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults((results) => {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(
      results.image, 0, 0, canvasElement.width, canvasElement.height);

    let faceCount = 0;
    if (results.multiFaceLandmarks) {
      faceCount = results.multiFaceLandmarks.length;
      for (const landmarks of results.multiFaceLandmarks) {
        const landmark10 = landmarks[10];
        const leftTemple = landmarks[234];
        const rightTemple = landmarks[454];

        if (landmark10 && leftTemple && rightTemple && hatImage.complete && hatImage.naturalWidth > 0) {
            const canvasWidth = canvasElement.width;
            const canvasHeight = canvasElement.height;

            const p10 = { x: landmark10.x * canvasWidth, y: landmark10.y * canvasHeight };
            const pLeftTemple = { x: leftTemple.x * canvasWidth, y: leftTemple.y * canvasHeight };
            const pRightTemple = { x: rightTemple.x * canvasWidth, y: rightTemple.y * canvasHeight };

            const headWidthPixels = Math.sqrt(Math.pow(pRightTemple.x - pLeftTemple.x, 2) + Math.pow(pRightTemple.y - pLeftTemple.y, 2));

            const hatScaleFactor = 1.8;
            const hatImageAspectRatio = hatImage.naturalWidth / hatImage.naturalHeight;
            const hatWidth = headWidthPixels * hatScaleFactor;
            const hatHeight = hatWidth / hatImageAspectRatio;

            const headCenterX = (pLeftTemple.x + pRightTemple.x) / 2;
            const headCenterY = (pLeftTemple.y + pRightTemple.y) / 2;
            
            const angle = Math.atan2(pRightTemple.y - pLeftTemple.y, pRightTemple.x - pLeftTemple.x);

            const hatCenterOffsetYFromTemples = headWidthPixels * 0.3;
            
            canvasCtx.save();

            canvasCtx.translate(headCenterX, headCenterY);
            canvasCtx.rotate(angle);

            const vecP10X = p10.x - headCenterX;
            const vecP10Y = p10.y - headCenterY;
            const cosMinusAngle = Math.cos(-angle);
            const sinMinusAngle = Math.sin(-angle);
            const localP10Y = vecP10X * sinMinusAngle + vecP10Y * cosMinusAngle;

            const yOffsetFromP10 = hatCenterOffsetYFromTemples - (hatHeight * 0.5);
            const hatCenterLocalY = localP10Y + yOffsetFromP10;

            const drawX = -hatWidth / 2;
            const drawY = hatCenterLocalY - (hatHeight / 2);

            canvasCtx.globalAlpha = 0.0;
            canvasCtx.drawImage(hatImage, drawX, drawY, hatWidth, hatHeight);
            canvasCtx.globalAlpha = 1.0;

            canvasCtx.restore();
        }
      }
    }
    // faceCountElement.textContent = `Faces detected: ${faceCount}`;
    canvasCtx.restore();
  });

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await faceMesh.send({image: videoElement});
    },
    width: 960,
    height: 720
  });

  camera.start();
</script>

</body>
</html>
